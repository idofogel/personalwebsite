const ReactNotReactive = () => {
    return (<div><p>React is not reactive<span className='outoffont'>.</span></p>
    <p>We all know this and still we keep calling React react and see no problem in continuing to code around this problem as if nothing is wrong<span className='outoffont'>.</span></p>
    <p>Let<span className='outoffont'>&#39;</span>s start from the beginning<span className='outoffont'>:</span> the reactivity principle mandates that when you perform some change in a reactive element like a state <span className='outoffont'>-</span> it will lead to an immediate reaction on the <span className='outoffont'>(</span>virtual<span className='outoffont'>)</span> DOM<span className='outoffont'>.</span></p>
    <p>That principle is not maintained in react because of two reasons we all know<span className='outoffont'>:</span></p>
    <p><span className='outoffont'>1.</span> changes in react elements <span className='outoffont'>(</span> like state<span className='outoffont'>)</span> lead to a scheduling of a change<span className='outoffont'>,</span> not an immediate change<span className='outoffont'>.</span> when you order to change a state<span className='outoffont'>,</span> react schedules your desired action to somewhere around the next render cycle<span className='outoffont'>.</span> that can be very fast<span className='outoffont'>.</span> but still not reactive<span className='outoffont'>.</span></p>
    <p><span className='outoffont'>2.</span> the second reason is manifested in the following example which I am sure you all are acquainted with<span className='outoffont'>:</span> suppose I declare the following hook<span className='outoffont'>:</span></p>
    const <span className='outoffont'>[</span>count<span className='outoffont'>,</span>setCount<span className='outoffont'>] =</span>useState<span className='outoffont'>(0);</span>

<p>and then write in the function<span className='outoffont'>:</span></p>
<p>setCount<span className='outoffont'>(</span>count<span className='outoffont'>+1);</span></p>
<p>setCount<span className='outoffont'>(</span>count<span className='outoffont'>+1);</span></p>
<p>setCount<span className='outoffont'>(</span>count<span className='outoffont'>+1);</span></p>
<p>The result would be count<span className='outoffont'>+1</span> only<span className='outoffont'>.</span> </p>
<p>That is because React is not reactive<span className='outoffont'>.</span> What we did in these <span className='outoffont'>3</span> lines of code was scheduling <span className='outoffont'>3</span> count<span className='outoffont'>+1</span> actions to the future<span className='outoffont'>.</span> React read each one when it was convenient for him and instead of referring to the count correct value it chose to referred to the old value from the time when we called the react scheduler<span className='outoffont'>.</span> This caused him to refer to the same value over and over and repeat the same activity <span className='outoffont'>3</span> times only to yield a wrong answer<span className='outoffont'>.</span></p>
<p>It<span className='outoffont'>&#39;</span>s not that react didn<span className='outoffont'>&#39;</span>t or couldn<span style={{fontFamily: 'Arial, Helvetica, sans-serif'}}>&#39;</span>t know the up<span className='outoffont'>-</span>to<span className='outoffont'>-</span>date value<span className='outoffont'>.</span> It did<span className='outoffont'>.</span> It just chose not to<span className='outoffont'>.</span></p>
<p>I can prove it easily<span className='outoffont'>:</span></p>
<p>if instead we would write our react schedules like this<span className='outoffont'>:</span><br />
setCount<span className='outoffont'>(</span>prevCount <span className='outoffont'>=&gt</span> prevCount<span className='outoffont'> + 1);</span><br />
setCount<span className='outoffont'>(</span>prevCount <span className='outoffont'>=&gt</span> prevCount<span className='outoffont'> + 1);</span><br />
setCount<span className='outoffont'>(</span>prevCount <span className='outoffont'>=&gt</span> prevCount<span className='outoffont'> + 1);</span></p>
<p>React would know the correct value in the time of the change even though we didn<span className='outoffont'>&#39;</span>t specify it and yield the correct count<span className='outoffont'>+3</span> result<span className='outoffont'>.</span>
A computerised product knows the correct answer but still insists on giving the wrong one<span className='outoffont'>,</span> by design<span className='outoffont'>.</span></p>
<p>Is it being a dick<span className='outoffont'>?</span> I don<span className='outoffont'>&#39;</span>t think so<span className='outoffont'>.</span></p>
<p>I just argued about it with chatGPT for the last <span className='outoffont'>3</span> hours<span className='outoffont'>.</span> ChatGPT gave up and gave me a lecture about a concept it called<span className='outoffont'>:&quot;</span>negotiating correctness<span className='outoffont'>&quot;.</span> This principle means that even though computer science is an exact science and that computer programs are supposed to always yield correct results according to their calculations<span className='outoffont'>,</span> sometimes it is better to negotiate the tradeoff between correctness with other <span className='outoffont'>&quot;</span>values<span className='outoffont'>&quot;</span> such as simplicity<span className='outoffont'>.</span></p>
    <h3>What<span className='outoffont'>??!!</span></h3>
    <p>I thought that getting correct results was the whole point of computers<span className='outoffont'>.</span> It turns out that computers are not so different from humans<span className='outoffont'>.</span> They have weaknesses<span className='outoffont'>,</span> they lie for what they think are good reasons<span className='outoffont'>.</span></p>
    <p>Is react trying to give me alternative facts<span className='outoffont'>?</span></p>
    <p>I noticed that also with AI chats<span className='outoffont'>.</span> They lie to me all the time<span className='outoffont'>!</span> say wrong answers<span className='outoffont'>,</span> say answers that contradict previous answers that they gave me<span className='outoffont'>.</span> When I confront them about their lies they don<span className='outoffont'>&#39;</span>t even hide it and continue to talk to me like nothing happened<span className='outoffont'>.</span></p>
    <p>When reading about AI and especially AGI algorithms it becomes easier to understand<span className='outoffont'>:</span> </p>
    <p>AGI analyzes statistically based on training sets what the next words it should yield based on what I wrote and what it answered and often chooses between several possible permutations of words<span className='outoffont'>.</span>
AGI<span className='outoffont'>,</span> like React<span className='outoffont'>,</span> is what happens when you choose to put less rigorous requirements to machines regarding correctness<span className='outoffont'>.</span> We sacrifice the truth <span className='outoffont'>(</span>at least partially<span className='outoffont'>)</span> in order to gain an extraordinary machine that can do amazing things<span className='outoffont'>.</span> We demanded less and got more<span className='outoffont'>.</span></p>
<p>I am not writing prose<span className='outoffont'>.</span> I am a computer programmer and I want a clear<span className='outoffont'>,</span> replicable crescendo to this problem<span className='outoffont'>:</span></p>
<p>On how much truth should we give up and in exchange to how much results<span className='outoffont'>?</span> <br />
It would also be great if the answer would come in an elegant formula<span className='outoffont'>.</span>
</p>
<p>When I was in Hebrew school<span className='outoffont'>,</span> in the last month of the year we would gather at night and pray for forgiveness for our sins<span className='outoffont'>.</span> Every night we would sing an ancient hymn that asks someone to ask for forgiveness on our behalf and every night a rabbi would go on stage and say why this hymn is wrong<span style={{fontFamily: 'Arial, Helvetica, sans-serif'}}>.</span> We should ask for forgiveness directly and not use intermediaries<span className='outoffont'>.</span></p>
<p>One day we asked him<span className='outoffont'>:</span>If singing this song is wrong shouldn<span style={{fontFamily: 'Arial, Helvetica, sans-serif'}}>&#39;</span>t we stop singing it every night<span className='outoffont'>?</span>
He said <span className='outoffont'>&quot;</span>no<span className='outoffont'>&quot;.</span> The fact that something is wrong does not necessarily mean that we shouldn<span style={{fontFamily: 'Arial, Helvetica, sans-serif'}}>&#39;</span>t do it<span className='outoffont'>.</span>
</p>
<p>React doesn<span className='outoffont'>&#39;</span>t need fixing<span className='outoffont'>.</span> It should stay flawed<span className='outoffont'>.</span> I thought a lot about what we should do with the setState<span className='outoffont'>(</span>non<span className='outoffont'>-</span>functional expression<span className='outoffont'>)</span> bug and had the following insight<span className='outoffont'>:</span></p>
<p>If we can live with the flaw of React<span className='outoffont'>,</span> learn to write around it even though there is a huge flaw in the middle of it and still have react as the most popular client side language there is and not look for replacements<span className='outoffont'>.</span> and if we can live with the fact that AGI lies a lot and still see at it as the greatest invention in the world<span className='outoffont'>,</span> maybe we can use the same approach to look</p>
    </div>);
}
export default ReactNotReactive;